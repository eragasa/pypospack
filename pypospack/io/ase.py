#!/usr/bin/env python
import ase.io
from ase.lattice.cubic import FaceCenteredCubic
from ase.lattice.cubic import BodyCenteredCubic
from ase.lattice.cubic import SimpleCubic
from ase.lattice.cubic import Diamond
from ase.lattice.hexagonal import HexagonalClosedPacked
import ase.build.bulk as asebulk
import numpy as np
import numpy.linalg as linalg

# all crystal names
supported_xtal_names = ['fcc','bcc','fcc','diamond']
supported_aliases = []

def make_structure(\
        symbol,
        structure,
        a,
        is_cubic=True,
        is_orthorhombic=False):
    """ creates an atomic structure
    Args:
        symbol(str): the ISO chemical symbol for atom type
        structure(str): structure type
        a(float): lattice parameter for the material
        is_cubic(bool): true
        is_orthorhombic(bool): false
    Returns:
        ase.atom.Atoms
    """
    sim_cell = asebulk(symbol, 
            structure, 
            a, 
            cubic=is_cubic,
            orthorhombic=is_orthorhombic)
    return sim_cell

def write_ase_structure(ase_cell, filename, fileformat):
    if fileformat  in ['vasp','poscar']:
        write_ase_structure_as_poscar(ase_cell, fname_out=filename)

def write_ase_structure_as_poscar(ase_cell, fname_out='POSCAR'):
    """ write the ase structure

    The standard version that ase uses for the POSCAR file is
    inadequate for our needs.

    Args:
       ase_cell(ase.atom.Atoms): the simulation cell
       fname_out(str): file name to be written to (default: 'POSCAR')

    Returns:
        str: a string of the POSCAR file which was written

    Raises:
        FileExceptionError: if the filename already exists.
    """
    assert type(ase_cell) is ase.atoms.Atoms, \
            "ase_cell not the correct type, {}".format(type(ase_cell))
    assert isinstance(fname_out,str), \
            "fname_out is not a string"

    symbols = list(sorted(set(ase_cell.get_chemical_symbols())))
    H = ase_cell.get_cell()
    lattice = [1.0,H]

    str_out = "generated by pyPOSpack\n"
    str_out += "{:10.6f}\n".format(lattice[0])
    for v in lattice[1]:
        str_out += "{:10.6f} {:10.6f} {:10.6f}\n".format(v[0],v[1],v[2])

    n_atoms_per_symbol = {}
    str_out += "".join(symbols) + "\n"
    for s in symbols:
        n_atoms = 0
        for a in ase_cell:
            if a.symbol == s:
                n_atoms += 1
        n_atoms_per_symbol[s] = n_atoms

    str_out += "".join([str(n_atoms_per_symbol[s]) for s in symbols]) + "\n"

    str_out += "Direct\n"

    for s in symbols:
        for a in ase_cell:
            if a.symbol == s:
                uvx = transform_cartesian_to_direct(\
                        v = a.position,
                        lattice = ase_cell.get_cell())
                str_out += "{:10.6f} {:10.6f} {:10.6f}\n".format(\
                        uvx[0],uvx[1],uvx[2])

    # write the string out to filename
    with open(fname_out,'x') as f:
        f.write(str_out)

    return str_out

def transform_cartesian_to_direct(v, lattice):
    """ transformation of cartesian coordinates to direct coordinates

    If the lattice is an H vector, with the rows being the lattice vectors, the
    if r is a column vector of the director coordinates of H, and x is the 
    Cartesian coordinates, then x = H.T r.

    Args:
        v(list): a list of floats representing the coordinates in the cartesian basis.
        lattice(list): a list of lists representing the lattice in H-matrix form

    Returns:
        list: a list of float representing the coordinates in the lattice vector.
    """
    # http://www.ruppweb.org/Xray/tutorial/Coordinate%20system%20transformation.htm

    # assert that we have the things we want
    assert isinstance(type(v),type(np.ndarray)),\
            "type(v) is {}".format(type(v))
    assert isinstance(type(lattice),type(np.ndarray)),\
            "type(lattice) is {}".format(type(lattice))

    # cast v as a column vector
    xyz = v[np.newaxis].T

    # cast the lattice as an H vector
    uvx = np.dot(linalg.inv(lattice.T),xyz)

    return uvx[:,0].tolist()

def transform_direct_to_cartesian(v, lattice):
    """ transformation of cartesian coordinates to direct coordinates

    Args:
        v(list): a list of floats representing the coordinates in the cartesian basis.
        lattice(list): a list of lists representing the lattice in H-matrix form

    Returns:
        list: a list of float representing the coordinates in the lattice vector.
    """
    
    assert isinstance(type(v),type(np.array)),\
            "type(v) is {}".format(type(v))
    assert isinstance(type(lattice),type(np.ndarray)),\
            "type(lattice) is {}".format(type(lattice))

    # cast v as a column vector
    uvw = v[np.newaxis].T

    xyz = np.dot(lattice.T,uvw)

    return xyz

def make_bulk_structure(symbols,
                        xtal_name,
                        a,
                        lattice_shape):

    is_cubic = None
    is_orthorhombic = None
    if lattice_shape is 'cubic':
        is_cubic = True
        is_orthorhombic = False
    elif lattice_shape is 'ortho':
        is_cubic = False
        is_orthorhombic = True
    elif lattice_shape is 'prim':
        is_cubic = False
        is_orthorhombic = False
    else:
        raise ValueException('lattice_shape must be cubic, ortho, or prim')

    xtal = None
    if xtal_name == 'dia':
        xtal = 'diamond'
    else:
        xtal = xtal_name
    s = None
    if len(symbols) == 1:
        s = symbols[0]

    print('making a cell:')
    print('\tsymbols:{}'.format(s))
    print('\txtal_name:{}'.format(xtal_name))
    print('\tlattice_shape:{}'.format(lattice_shape))
    print('\tis_cubic={}'.format(is_cubic))
    print('\tis_orthorhombic={}'.format(is_orthorhombic))
    print('\ta={:10.6f}'.format(a))
    # make ase simulation cell
    cell = make_structure(\
            s,xtal,a,
            is_cubic=is_cubic,
            is_orthorhombic=is_orthorhombic)

    fname_out = "{}_{}_{}.vasp".format("".join(symbols),xtal_name,lattice_shape)

    write_ase_structure_as_poscar(\
            ase_cell = cell,
            fname_out = fname_out)

def get_atomic_radius(symbol):
    if symbol == 'Ni':
        return  (0.5/(2**0.5))*3.524

def determine_direction_vectors_for_surface(direction=[1,1,1]):
    direction_z = np.array(direction)
    point_1 = [direction_z[0],0,0]
    point_2 = [0,direction_z[1],0]
    point_3 = [0,0,direction_z[2]]
    
    direction_x = (np.array(point_3) - np.array(point_2))
    direction_y = np.cross(
            direction_z,
            direction_x
        )
    return [ 
            direction_x.tolist(),
            direction_y.tolist(),
            direction_z.tolist()
            ]

def make_fcc_100_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [1,0,0]
    direction_y = [0,1,0]
    direction_z = [0,0,1]

    atoms = FaceCenteredCubic(\
            directions=[direction_x,direction_y,direction_z],
            size=size,
            symbol=symbols[0],
            pbc=pbc)

    return atoms

def make_fcc_111_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    _surface_direction = [1,1,1]

    directions = determine_direction_vectors_for_surface(
            direction=_surface_direction
        )

    size=(1,1,1)
    atoms = FaceCenteredCubic(\
            directions=directions,
            size=size,
            symbol=symbols[0],
            pbc=pbc)

    return atoms

def make_fcc_110_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [0,0,1]
    direction_y = [1,-1,0]
    direction_z = [1,1,0]

    atoms = FaceCenteredCubic(\
            directions=[direction_x,direction_y,direction_z],
            size=size,
            symbol=symbols[0],
            pbc=pbc)
    return atoms

def make_bcc_100_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [1,0,0]
    direction_y = [0,1,0]
    direction_z = [0,0,1]

    directions = [direction_x,direction_y,direction_z]
    atoms = None
    try:
        atoms = BodyCenteredCubic(\
                directions=directions,
                size=size,
                symbol=symbols[0],
                pbc=pbc)
    except ValueError as e:
        if str(e) == 'Cannot guess the bcc lattice constant of an element with crystal structure fcc.':
            r = get_atomic_radius(symbol=symbols[0])
            a0 = 4*r/(3**0.5)
            atoms = BodyCenteredCubic(\
                    directions=directions,
                    size=size,
                    symbol=symbols[0],
                    pbc=pbc,
                    latticeconstant=a0)
        else:
            raise ValueError('cannot create the bcc structure')
    return atoms

def make_sc_100_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [1,0,0]
    direction_y = [0,1,0]
    direction_z = [0,0,1]
    directions = [direction_x,direction_y,direction_z]

    atoms = None
    try:
        atoms = SimpleCubic(\
                directions=[direction_x,direction_y,direction_z],
                size=size,
                symbol=symbols[0],
                pbc=pbc)
    except ValueError as e:
        if str(e) == 'Cannot guess the sc lattice constant of an element with crystal structure fcc.':
            r = get_atomic_radius(symbol=symbols[0])
            a0 = 2*r
            atoms = SimpleCubic(\
                    directions=directions,
                    size=size,
                    symbol=symbols[0],
                    pbc=pbc,
                    latticeconstant=a0)
        else:
            raise ValueError('cannot create the simple cubic structure')
    return atoms

def make_dia_100_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [1,0,0]
    direction_y = [0,1,0]
    direction_z = [0,0,1]

    atoms = None
    try:
        atoms = Diamond(\
                directions=[direction_x,direction_y,direction_z],
                size=size,
                symbol=symbols[0],
                pbc=pbc)
    except ValueError as e:
        if str(e) == 'Cannot guess the diamond lattice constant of an element with crystal structure fcc.':
            r = get_atomic_radius(symbol=symbols[0])
            a0 = 3.567
            atoms = Diamond(\
                    directions=[direction_x,direction_y,direction_z],
                    size=size,
                    symbol=symbols[0],
                    pbc=pbc,
                    latticeconstant=a0)
        else:
            raise ValueError("cannnot create the diamond cubic structure")
    return atoms

def make_hcp_0001_cell(size=(1,1,1),symbols=['Ni'],pbc=(1,1,1)):
    direction_x = [2,-1,-1,0]
    direction_y = [0,1,-1,0]
    direction_z = [0,0,0,1]

    directions=[direction_x,direction_y,direction_z]
    atoms = None
    try:
        atoms = HexagonalClosedPacked(
            directions=[direction_x,direction_y,direction_z],
            size=size,
            symbol=symbols[0],
            pbc=pbc)
    except ValueError as e:
        if str(e) == 'Cannot guess the hcp lattice constant of an element with crystal structure fcc.':
            r = get_atomic_radius(symbol=symbols[0])
            _lattice_constants = {}
            _lattice_constants['a'] = r
            _lattice_constants['c/a'] = 1.663
            
            atoms = HexagonalClosedPacked(\
                    directions=directions,
                    size=size,
                    symbol=symbols[0],
                    pbc=pbc,
                    latticeconstant=_lattice_constants)
        else:
            raise
    return atoms
if __name__ == "__main__":
    symbol = 'Ni'
    structure = 'fcc'
    a = 3.508

    # create the orthogonal unit cell
    cell = make_structure(symbol,
            structure,
            a,
            is_cubic=True)

    # create the nonorthgonal unit cell
    try:
        write_ase_structure_as_poscar(
                ase_cell = cell, 
                fname_out='Ni_fcc_unit.vasp')
    except FileExistsError:
        print("the file exists")
