#!/usr/bin/env python
import ase.io
import ase.build.bulk as asebulk
import numpy as np
import numpy.linalg as linalg

# all crystal names
supported_xtal_names = ['fcc','bcc','fcc','diamond']
supported_aliases = []

def make_structure(\
        symbol,
        structure,
        a,
        is_cubic=True,
        is_orthorhombic=False):
    """ creates an atomic structure
    Args:
        symbol(str): the ISO chemical symbol for atom type
        structure(str): structure type
        a(float): lattice parameter for the material
        is_cubic(bool): true
        is_orthorhombic(bool): false
    Returns:
        ase.atom.Atoms
    """
    sim_cell = asebulk(symbol, 
            structure, 
            a, 
            cubic=is_cubic,
            orthorhombic=is_orthorhombic)
    return sim_cell

def write_ase_structure(ase_cell, filename, fileformat):
    if fileformat  in ['vasp','poscar']:
        write_ase_structure_as_poscar(ase_cell, fname_out=filename)

def write_ase_structure_as_poscar(ase_cell, fname_out='POSCAR'):
    """ write the ase structure

    The standard version that ase uses for the POSCAR file is
    inadequate for our needs.

    Args:
       ase_cell(ase.atom.Atoms): the simulation cell
       fname_out(str): file name to be written to (default: 'POSCAR')

    Returns:
        str: a string of the POSCAR file which was written

    Raises:
        FileExceptionError: if the filename already exists.
    """
    assert type(ase_cell) is ase.atoms.Atoms, \
            "ase_cell not the correct type, {}".format(type(ase_cell))
    assert isinstance(fname_out,str), \
            "fname_out is not a string"

    symbols = list(sorted(set(ase_cell.get_chemical_symbols())))
    H = ase_cell.get_cell()
    lattice = [1.0,H]

    str_out = "generated by pyPOSpack\n"
    str_out += "{:10.6f}\n".format(lattice[0])
    for v in lattice[1]:
        str_out += "{:10.6f} {:10.6f} {:10.6f}\n".format(v[0],v[1],v[2])

    n_atoms_per_symbol = {}
    str_out += "".join(symbols) + "\n"
    for s in symbols:
        n_atoms = 0
        for a in ase_cell:
            if a.symbol == s:
                n_atoms += 1
        n_atoms_per_symbol[s] = n_atoms

    str_out += "".join([str(n_atoms_per_symbol[s]) for s in symbols]) + "\n"

    str_out += "Direct\n"

    for s in symbols:
        for a in ase_cell:
            if a.symbol == s:
                uvx = transform_cartesian_to_direct(\
                        v = a.position,
                        lattice = ase_cell.get_cell())
                str_out += "{:10.6f} {:10.6f} {:10.6f}\n".format(\
                        uvx[0],uvx[1],uvx[2])

    # write the string out to filename
    with open(fname_out,'x') as f:
        f.write(str_out)

    return str_out

def transform_cartesian_to_direct(v, lattice):
    """ transformation of cartesian coordinates to direct coordinates

    If the lattice is an H vector, with the rows being the lattice vectors, the
    if r is a column vector of the director coordinates of H, and x is the 
    Cartesian coordinates, then x = H.T r.

    Args:
        v(list): a list of floats representing the coordinates in the cartesian basis.
        lattice(list): a list of lists representing the lattice in H-matrix form

    Returns:
        list: a list of float representing the coordinates in the lattice vector.
    """
    # http://www.ruppweb.org/Xray/tutorial/Coordinate%20system%20transformation.htm

    # assert that we have the things we want
    assert isinstance(type(v),type(np.ndarray)),\
            "type(v) is {}".format(type(v))
    assert isinstance(type(lattice),type(np.ndarray)),\
            "type(lattice) is {}".format(type(lattice))

    # cast v as a column vector
    xyz = v[np.newaxis].T

    # cast the lattice as an H vector
    uvx = np.dot(linalg.inv(lattice.T),xyz)

    return uvx[:,0].tolist()

def transform_direct_to_cartesian(v, lattice):
    """ transformation of cartesian coordinates to direct coordinates

    Args:
        v(list): a list of floats representing the coordinates in the cartesian basis.
        lattice(list): a list of lists representing the lattice in H-matrix form

    Returns:
        list: a list of float representing the coordinates in the lattice vector.
    """
    
    assert isinstance(type(v),type(np.array)),\
            "type(v) is {}".format(type(v))
    assert isinstance(type(lattice),type(np.ndarray)),\
            "type(lattice) is {}".format(type(lattice))

    # cast v as a column vector
    uvw = v[np.newaxis].T

    xyz = np.dot(lattice.T,uvw)

    return xyz

def make_bulk_structure(symbols,
                        xtal_name,
                        a,
                        lattice_shape):

    is_cubic = None
    is_orthorhombic = None
    if lattice_shape is 'cubic':
        is_cubic = True
        is_orthorhombic = False
    elif lattice_shape is 'ortho':
        is_cubic = False
        is_orthorhombic = True
    elif lattice_shape is 'prim':
        is_cubic = False
        is_orthorhombic = False
    else:
        raise ValueException('lattice_shape must be cubic, ortho, or prim')

    xtal = None
    if xtal_name == 'dia':
        xtal = 'diamond'
    else:
        xtal = xtal_name
    s = None
    if len(symbols) == 1:
        s = symbols[0]

    print('making a cell:')
    print('\tsymbols:{}'.format(s))
    print('\txtal_name:{}'.format(xtal_name))
    print('\tlattice_shape:{}'.format(lattice_shape))
    print('\tis_cubic={}'.format(is_cubic))
    print('\tis_orthorhombic={}'.format(is_orthorhombic))
    print('\ta={:10.6f}'.format(a))
    # make ase simulation cell
    cell = make_structure(\
            s,xtal,a,
            is_cubic=is_cubic,
            is_orthorhombic=is_orthorhombic)

    fname_out = "{}_{}_{}.vasp".format("".join(symbols),xtal_name,lattice_shape)

    write_ase_structure_as_poscar(\
            ase_cell = cell,
            fname_out = fname_out)

if __name__ == "__main__":
    symbol = 'Ni'
    structure = 'fcc'
    a = 3.508

    # create the orthogonal unit cell
    cell = make_structure(symbol,
            structure,
            a,
            is_cubic=True)

    # create the nonorthgonal unit cell
    try:
        write_ase_structure_as_poscar(
                ase_cell = cell, 
                fname_out='Ni_fcc_unit.vasp')
    except FileExistsError:
        print("the file exists")
